package NateQuest.ActionItems;

import java.lang.reflect.Array;
import java.util.ArrayList;

import GameClasses.CUtil;
import GameClasses.Sprite;
import NateQuest.Debugger;
import NateQuest.Entity;
import NateQuest.GameScreen;
import NateQuest.ImageCreator;
import NateQuest.Drawables.DrawableLine;
import NateQuest.Drawables.DrawableWithText;
import NateQuest.Drawables.LayerConstants;
import UserInterface.DanMenu;

public class Actionable extends Entity {

	final int DEBUG_LIST_X = 300;
	final int DEBUG_LIST_Y = 400;
	final int DEBUG_BOX_OFF_X = 300;
	final int DEBUG_BOX_OFF_Y = 0;
	final int TEXT_SPACING = 25;
	final int TEXT_WIDTH = 600;

	// Action choices are marked by the order of strings;
	public ArrayList<String> possibleActions;
	public ArrayList<ActionLink>[] links;

	public Actionable(GameScreen gs) {
		super(gs);
	}

	protected void addOps(String[] ops) {
		possibleActions = new ArrayList<String>();
		for (int i = 0; i < ops.length; i++) {
			possibleActions.add(ops[i]);
		}

		links = new ArrayList[ops.length];
		for (int i = 0; i < links.length; i++) {
			links[i] = new ArrayList<ActionLink>();
		}
	}

	// Do some sort of action
	public void action(int actionID, Entity caller) {

	}

	public DanMenu createMenuToSelectAction() {
		DanMenu menu = new DanMenu(parentScreen, possibleActions);
		return menu;
	}

	// For the level editor
	public ArrayList<DrawableWithText> createTextListOfCurrentActions() {
		ArrayList<DrawableWithText> dwts = new ArrayList<DrawableWithText>();
		for (int i = 0; i < possibleActions.size(); i++) {
			for (ActionLink link : links[i]) {
				DrawableWithText d = new DrawableWithText(this, null,
						LayerConstants.DEBUG, link.toString());
				d.setPosition(DEBUG_LIST_X, DEBUG_LIST_Y
						+ (dwts.size() * TEXT_SPACING));
				dwts.add(d);
			}
		}
		Sprite s = new Sprite(ImageCreator.createImage(TEXT_WIDTH, dwts.size()
				* TEXT_SPACING, 200, 170, 190, 255));
		s.bIsCameraed = false;
		DrawableWithText box = new DrawableWithText(this, s,
				LayerConstants.TILEMAP_OVERLAY, "*");
		box.setPosition(DEBUG_LIST_X + DEBUG_BOX_OFF_X, DEBUG_LIST_Y
				+ DEBUG_BOX_OFF_Y + (dwts.size() * TEXT_SPACING / 2));
		dwts.add(box);
		for (DrawableWithText d : dwts) {
			d.setIsCamerad(false);
		}
		return dwts;
	}

	public ArrayList<DrawableLine> createLineListOfCurrentActions() {
		ArrayList<DrawableLine> dls = new ArrayList<DrawableLine>();
		for (int i = 0; i < possibleActions.size(); i++) {
			for (ActionLink link : links[i]) {
				DrawableLine line = new DrawableLine(this, LayerConstants.DEBUG);
				line.setTargets(this.position, link.target.position);
				dls.add(line);
			}
		}
		return dls;
	}

	public void addActionLink(ActionLink link) {
		// check for duplicates
		for (ActionLink actlink : links[link.sourceActID]) {
			if (actlink.equals(link)) {
				Debugger.print("Link already exists: Src: " + this.toString()
						+ " SrcAct: " + possibleActions.get(link.sourceActID)
						+ " Target: " + link.target + " TrgAct: "
						+ link.target.possibleActions.get(link.targetActID));
				return;
			}
		}
		if (checkForActionCycles(link)) {
			Debugger.print("Link cycle exists: Src: " + this.toString()
					+ " SrcAct: " + possibleActions.get(link.sourceActID)
					+ " Target: " + link.target + " TrgAct: "
					+ link.target.possibleActions.get(link.targetActID));
			return;
		}
		links[link.sourceActID].add(link);
	}

	// see if we have any infinite loops generated by this action
	public boolean checkForActionCycles(ActionLink sourcelink) {

		for (ActionLink link : sourcelink.target.links[sourcelink.targetActID]) {
			if (link.willNextHop(sourcelink)) {
				Debugger.print("fouund cycle");
				return true;
			} else {
				boolean res = link.target.checkForActionCyclesHelper(
						sourcelink, link);
				if (res) {
					return true;
				}
			}
		}

		return false;

		/*
		 * boolean anydups = false; Debugger.print("Cycle check, " +
		 * links[sourcelink.sourceActID].size() + " ops "); for (ActionLink link
		 * : links[sourcelink.sourceActID]){ if (link.willNextHop(sourcelink)){
		 * Debugger.print("found cycle"); return true; } else { anydups =
		 * link.target.checkForActionCyclesHelper(sourcelink, link.targetActID);
		 * if (anydups) { Debugger.print("found in helper"); return true; } } }
		 * return anydups;
		 */
	}

	public boolean checkForActionCyclesHelper(ActionLink sourcelink,
			ActionLink path) {

		for (ActionLink link : path.target.links[path.targetActID]) {
			if (link.willNextHop(sourcelink)) {
				Debugger.print("fouund cycle");
				return true;
			} else {
				boolean res = link.target.checkForActionCyclesHelper(
						sourcelink, link);
				if (res) {
					return true;
				}
			}
		}

		return false;
		/*
		 * boolean anydups = false; Debugger.print("in helper, " +
		 * links[path].size() + " options ");
		 * 
		 * for (ActionLink link : links[path]){ if (link.equals(sourcelink)){
		 * return true; } else { if (
		 * link.target.checkForActionCyclesHelper(sourcelink, link.targetActID)
		 * ){ anydups = true; } } } return anydups;
		 */
	}

	// Play the actions of everything this is linked to
	public void playActions(int actionID) {
		for (ActionLink link : links[actionID])
			link.performAction();
	}

	public int stringToActionID(String name) {
		for (int i = 0; i < possibleActions.size(); i++) {
			if (possibleActions.get(i).equals(name)) {
				return i;
			}
		}
		Debugger.print("Action: " + name + " couldn't be found. Candidates - ");
		for (String s : possibleActions)
			Debugger.print(s);
		return -1;
	}

}
